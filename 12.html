<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Krishi Suvidha - AR Field Measure</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap"
    rel="stylesheet">

  <!-- Styles -->
  <link rel="stylesheet" href="main.css">
  <!-- Using ar-measure.css as the primary source of truth for this page's style -->
</head>

<body>

  <!-- Topbar -->
  <div class="topbar">
    <div class="topbar-inner">
      <div>
        <span>‚úâÔ∏è ayushsk2041@gmail.com</span>
        <span style="margin-left: 15px;">üìû +91 8961103171</span>
      </div>
      <div id="google_translate_element"></div>
    </div>
  </div>

  <!-- Header -->
  <header class="site-header">
    <div class="header-inner">
      <a href="index.html" class="brand">
        <span>üå± Krishi Suvidha</span>
      </a>
      <nav class="nav">
        <a href="index.html#home">Home</a>
        <a href="Grains.html">Grains</a>
        <a href="vegetables-dashboard.html">Vegetables</a>
        <a href="products-dashboard.html">Products</a>
        <a href="orders-dashboard.html">Orders</a>
        <a href="about-dashboard.html">About</a>
        <a href="contact-dashboard.html">Contact</a>
        <a href="#" class="btn btn-primary" style="padding: 6px 16px; margin-left: 10px;">Chat & Quote</a>
      </nav>
    </div>
  </header>

  <div class="wrapper">
    <div class="ar-layout">

      <!-- Main Viewport Panel -->
      <div class="card-panel">
        <div class="card-header">
          <h2 class="card-title">üì∑ Camera View</h2>
          <div class="input-group">
            <span style="font-size:0.85rem; color:#64748b;">Scale (m/px):</span>
            <input id="scale-input" type="number" step="0.0001" value="0.01" />
          </div>
        </div>

        <div class="video-wrapper">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="draw-canvas"></canvas>
          <div id="point-markers"></div>
        </div>

        <div class="toolbar">
          <button id="btn-3d" class="btn btn-primary">
            <span>üßä View 3D Model</span>
          </button>
          <div style="flex:1"></div>
          <button id="btn-undo" class="btn btn-secondary">
            <span>Undo</span>
          </button>
          <button id="btn-clear" class="btn btn-danger">
            <span>Reset All</span>
          </button>
        </div>

        <div class="stats-bar">
          <div class="stat-item">
            <div class="stat-label">Total Distance</div>
            <div class="stat-value" id="summary-distance">0 m</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">Area</div>
            <div class="stat-value" id="summary-area">0 m¬≤</div>
          </div>
        </div>
        <div id="summary" style="display:none"></div>
        <!-- Legacy ID for JS compatibility if needed, but we will update JS to write to new IDs if possible, or keep this hidden and sync -->
      </div>

      <!-- Side Panel -->
      <div class="card-panel">
        <div class="card-header">
          <h3 class="card-title">üìç Points</h3>
        </div>
        <div id="point-list" class="points-list">
          <!-- Points injected here -->
          <div style="padding:20px; text-align:center; color:#94a3b8; font-size:0.9rem;">
            Click on the video to add measurement points.
          </div>
        </div>

        <div style="margin-top: auto; padding-top: 20px; border-top: 1px solid var(--border);">
          <h4 style="margin-bottom:12px; font-size:0.95rem; color:var(--dark);">Quick Exports</h4>
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
            <button id="btn-export-obj" class="btn btn-secondary" style="font-size:0.8rem;">Save OBJ</button>
            <button id="btn-export-gltf" class="btn btn-secondary" style="font-size:0.8rem;">Save GLTF</button>
          </div>
          <button id="btn-screenshot" class="btn btn-secondary"
            style="width:100%; margin-top:10px; font-size:0.8rem;">Save Screenshot</button>
        </div>
      </div>

    </div>
  </div>

  <!-- Fullscreen 3D Modal -->
  <div class="modal" id="modal-3d" role="dialog" aria-hidden="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 style="font-size:1.1rem;">Interactive 3D View</h3>
        <div class="modal-controls">
          <div class="input-group">
            <span style="font-size:0.85rem; color:#64748b;">Extrude (m):</span>
            <input id="extrude-height" type="number" step="0.01" value="0.2" />
          </div>
          <button id="modal-close" class="btn btn-secondary">Close</button>
        </div>
      </div>

      <div class="modal-body">
        <div id="three-container" style="width:100%; height:100%;"></div>

        <!-- Floating HUD for 3D view -->
        <div class="floating-info" id="three-info"></div>

        <div
          style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display:flex; gap:12px; background: rgba(255,255,255,0.9); padding: 8px 12px; border-radius: 99px; box-shadow: var(--shadow-lg);">
          <button id="modal-export-obj" class="btn btn-primary" style="padding: 8px 16px; font-size:0.8rem;">üì•
            OBJ</button>
          <button id="modal-export-gltf" class="btn btn-primary" style="padding: 8px 16px; font-size:0.8rem;">üì•
            GLTF</button>
          <button id="modal-screenshot" class="btn btn-secondary" style="padding: 8px 16px; font-size:0.8rem;">üì∏
            Shot</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Three.js Setup -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

    (function () {
      // Elements
      const video = document.getElementById('video');
      const drawCanvas = document.getElementById('draw-canvas');
      const ctx = drawCanvas.getContext('2d');
      const markers = document.getElementById('point-markers');
      const btnClear = document.getElementById('btn-clear');
      const btnUndo = document.getElementById('btn-undo');
      const btn3D = document.getElementById('btn-3d');
      const scaleInput = document.getElementById('scale-input');
      const summaryDistance = document.getElementById('summary-distance');
      const summaryArea = document.getElementById('summary-area');
      const pointList = document.getElementById('point-list');
      const btnExportOBJ = document.getElementById('btn-export-obj');
      const btnExportGLTF = document.getElementById('btn-export-gltf');
      const btnScreenshot = document.getElementById('btn-screenshot');

      // 3D modal elements
      const modal = document.getElementById('modal-3d');
      const threeContainer = document.getElementById('three-container');
      const modalClose = document.getElementById('modal-close');
      const modalExportOBJ = document.getElementById('modal-export-obj');
      const modalExportGLTF = document.getElementById('modal-export-gltf');
      const modalScreenshot = document.getElementById('modal-screenshot');
      const extrudeHeightInput = document.getElementById('extrude-height');
      const threeInfo = document.getElementById('three-info');

      // Data
      let points = []; // click points
      let scale = parseFloat(scaleInput.value) || 0.01;

      // Resize
      function resizeCanvas() {
        if (video.videoWidth) {
          drawCanvas.width = video.clientWidth;
          drawCanvas.height = video.clientHeight;
        }
      }
      window.addEventListener('resize', resizeCanvas);
      video.addEventListener('loadedmetadata', resizeCanvas);

      // Camera
      async function startCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment' },
            audio: false
          });
          video.srcObject = stream;
          await video.play();
          resizeCanvas();
        } catch (e) {
          console.error(e);
          alert('Camera access denied. Please allow camera permissions.');
        }
      }
      startCamera();

      // UI Helpers
      function addMarker(x, y) {
        const m = document.createElement('div');
        m.className = 'point-marker';
        m.style.left = x + 'px';
        m.style.top = y + 'px';
        markers.appendChild(m);
        return m;
      }
      function clearMarkers() { markers.innerHTML = ''; }

      // Interaction
      video.addEventListener('click', (ev) => {
        const rect = video.getBoundingClientRect();
        const screenX = ev.clientX - rect.left;
        const screenY = ev.clientY - rect.top;
        points.push({ pxX: screenX, pxY: screenY });
        addMarker(screenX, screenY);
        redraw();
        updateSummary();
        renderPointList();
      });

      // Canvas Drawing
      function redraw() {
        drawCanvas.width = video.clientWidth; // Ensure sync
        drawCanvas.height = video.clientHeight;

        ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        if (points.length < 1) return;

        ctx.lineWidth = 3;
        ctx.strokeStyle = "#ffc107"; // Accent color
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        ctx.beginPath();
        ctx.moveTo(points[0].pxX, points[0].pxY);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].pxX, points[i].pxY);
        }
        ctx.stroke();

        if (points.length >= 3) {
          ctx.beginPath();
          ctx.moveTo(points[0].pxX, points[0].pxY);
          for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].pxX, points[i].pxY);
          ctx.closePath();
          ctx.globalAlpha = 0.15;
          ctx.fillStyle = "#ffc107";
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Labels
        for (let i = 1; i < points.length; i++) {
          drawDistanceLabel(points[i - 1], points[i]);
        }
        if (points.length >= 3) {
          // Optional: Close loop label?
        }
      }

      function drawDistanceLabel(p1, p2) {
        const midX = (p1.pxX + p2.pxX) / 2;
        const midY = (p1.pxY + p2.pxY) / 2;
        const distPx = Math.hypot(p1.pxX - p2.pxX, p1.pxY - p2.pxY);
        const distM = (distPx * scale).toFixed(2);

        // Background pill
        const text = distM + " m";
        ctx.font = "bold 12px Montserrat";
        const width = ctx.measureText(text).width;

        ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
        ctx.beginPath();
        ctx.roundRect(midX - width / 2 - 6, midY - 10, width + 12, 20, 6);
        ctx.fill();

        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, midX, midY);
      }

      function updateSummary() {
        if (points.length < 2) {
          summaryDistance.textContent = '0 m';
          summaryArea.textContent = '0 m¬≤';
          return;
        }
        let totalPx = 0;
        for (let i = 1; i < points.length; i++) {
          totalPx += Math.hypot(points[i].pxX - points[i - 1].pxX, points[i].pxY - points[i - 1].pxY);
        }
        const totalM = (totalPx * scale).toFixed(2);
        summaryDistance.textContent = `${totalM} m`;

        if (points.length >= 3) {
          const areaPx = polygonAreaPx(points);
          const areaM2 = (areaPx * scale * scale).toFixed(2);
          summaryArea.textContent = `${areaM2} m¬≤`;
        } else {
          summaryArea.textContent = '0 m¬≤';
        }
      }

      function polygonAreaPx(pts) {
        let sum = 0;
        for (let i = 0; i < pts.length; i++) {
          const a = pts[i];
          const b = pts[(i + 1) % pts.length];
          sum += (a.pxX * b.pxY) - (b.pxX * a.pxY);
        }
        return Math.abs(sum / 2);
      }

      function renderPointList() {
        pointList.innerHTML = '';
        if (points.length === 0) {
          pointList.innerHTML = `<div style="padding:20px; text-align:center; color:#94a3b8; font-size:0.9rem;">Click on the video to add measurement points.</div>`;
          return;
        }
        points.forEach((p, i) => {
          const div = document.createElement('div');
          div.className = 'point-item';
          const pxToM = (val) => (val * scale).toFixed(2);
          div.innerHTML = `
            <div class="point-info">
                <span class="point-index">${i + 1}</span>
                <span style="font-size:0.85rem; color:#475569;">x:${pxToM(p.pxX)}, y:${pxToM(p.pxY)}</span>
            </div>
            <button data-index="${i}" class="btn-danger remove-btn" style="padding:4px 8px;">√ó</button>
          `;
          pointList.appendChild(div);
        });

        document.querySelectorAll('.remove-btn').forEach(btn => {
          btn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const idx = parseInt(btn.getAttribute('data-index'));
            points.splice(idx, 1);
            rebuildMarkers();
            redraw();
            updateSummary();
            renderPointList();
          });
        });
      }

      function rebuildMarkers() {
        markers.innerHTML = '';
        points.forEach(p => addMarker(p.pxX, p.pxY));
      }

      // Actions
      btnClear.addEventListener('click', () => {
        points = [];
        markers.innerHTML = '';
        ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        updateSummary();
        renderPointList();
      });
      btnUndo.addEventListener('click', () => {
        points.pop();
        rebuildMarkers();
        redraw();
        updateSummary();
        renderPointList();
      });

      scaleInput.addEventListener('change', () => {
        scale = parseFloat(scaleInput.value) || 0.01;
        updateSummary();
        redraw();
        renderPointList(); // Updates coords in list
      });

      // 3D Logic
      let renderer, scene, camera, controls, modelMesh;
      function initThree(container) {
        while (container.firstChild) container.removeChild(container.firstChild);

        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0x000000, 0); // Transparent background
        container.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        // Light background for the scene itself not needed if we want it transparent, 
        // but let's give it a subtle grid.

        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.01, 1000);
        camera.position.set(2, 2, 2);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lights
        const amb = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(amb);
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(5, 10, 5);
        scene.add(dir);

        // Grid
        const grid = new THREE.GridHelper(20, 20, 0xcbd5e1, 0xe2e8f0);
        scene.add(grid);

        window.addEventListener('resize', () => {
          if (!renderer || !modal.offsetParent) return; // Only if visible
          const w = container.clientWidth;
          const h = container.clientHeight;
          renderer.setSize(w, h);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        });

        function animate() {
          if (!renderer) return;
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        }
        animate();
      }

      function build3DModel(extrudeHeight) {
        if (modelMesh) { scene.remove(modelMesh); modelMesh = null; }
        if (points.length < 3) return;

        // Convert to meter-space 2D shape centered at 0,0
        const vertsMeters = points.map(p => ({ x: (p.pxX * scale), z: (p.pxY * scale) }));
        // Invert Y? Screen Y goes down, 3D Z goes whatever. Let's map Screen Y to 3D Z.

        // Centering
        let cx = 0, cz = 0;
        vertsMeters.forEach(v => { cx += v.x; cz += v.z; });
        cx /= vertsMeters.length;
        cz /= vertsMeters.length;

        const shape = new THREE.Shape();
        vertsMeters.forEach((v, i) => {
          const x = v.x - cx;
          const z = v.z - cz;
          if (i === 0) shape.moveTo(x, z);
          else shape.lineTo(x, z);
        });
        shape.closePath();

        const geom = new THREE.ExtrudeGeometry(shape, {
          depth: extrudeHeight,
          bevelEnabled: true,
          bevelThickness: 0.02,
          bevelSize: 0.02,
          bevelSegments: 2
        });
        // Rotate so it lays flat on grid (Extrude creates along Z usually, we want that to be vertical Y?)
        // Actually Extrude geometry extrudes along Z. We want "Depth" to be UP (Y).
        // So rotate X -90.
        geom.rotateX(Math.PI / 2);

        const mat = new THREE.MeshStandardMaterial({
          color: 0x1f8f4a,
          roughness: 0.3,
          metalness: 0.1,
          side: THREE.DoubleSide
        });
        modelMesh = new THREE.Mesh(geom, mat);
        // Center vertically based on height? Grid is at Y=0.
        // If we rotated -90 deg X. 
        modelMesh.position.y = extrudeHeight; // Just to be safe or adjust
        // Reset position to center
        modelMesh.position.set(0, 0, 0);

        scene.add(modelMesh);

        // Edges
        const edges = new THREE.EdgesGeometry(geom);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x0f172a, transparent: true, opacity: 0.3 }));
        scene.add(line);

        // Auto fitting camera
        const box = new THREE.Box3().setFromObject(modelMesh);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);

        controls.target.copy(center);
        camera.position.set(center.x + maxDim * 2, center.y + maxDim * 1.5, center.z + maxDim * 2);
        controls.update();

        showInfo(vertsMeters);
      }

      function showInfo(verts) {
        // Shoelace area
        let sum = 0;
        for (let i = 0; i < verts.length; i++) {
          const a = verts[i];
          const b = verts[(i + 1) % verts.length];
          sum += a.x * b.z - b.x * a.z;
        }
        const area = Math.abs(sum / 2);
        const ft = (area * 10.764);
        const txt = `Area: ${area.toFixed(2)} m¬≤\n(${ft.toFixed(2)} sq ft)`;

        threeInfo.innerText = txt;
        threeInfo.classList.add('visible');
        setTimeout(() => threeInfo.classList.remove('visible'), 8000);
      }

      btn3D.addEventListener('click', () => {
        if (points.length < 3) { alert('Need at least 3 points.'); return; }
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        // Wait for display flex to take effect for sizing
        requestAnimationFrame(() => {
          initThree(threeContainer);
          build3DModel(parseFloat(extrudeHeightInput.value) || 0.2);
        });
      });

      modalClose.addEventListener('click', () => {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        if (renderer) {
          renderer.dispose();
          renderer = null;
        }
      });

      extrudeHeightInput.addEventListener('change', () => {
        if (renderer && modelMesh) {
          build3DModel(parseFloat(extrudeHeightInput.value) || 0.2);
        }
      });

      // Exports
      function dl(fname, txt) {
        const b = new Blob([txt], { type: 'text/plain' });
        const u = URL.createObjectURL(b);
        const a = document.createElement('a'); a.href = u; a.download = fname;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(u);
      }
      modalExportOBJ.addEventListener('click', () => {
        if (!modelMesh) return;
        const res = new OBJExporter().parse(modelMesh);
        dl('measure-model.obj', res);
      });
      modalExportGLTF.addEventListener('click', () => {
        if (!modelMesh) return;
        new GLTFExporter().parse(modelMesh, (gltf) => {
          dl('measure-model.gltf', JSON.stringify(gltf));
        });
      });
      modalScreenshot.addEventListener('click', () => {
        if (renderer) {
          const u = renderer.domElement.toDataURL('image/png');
          const a = document.createElement('a'); a.href = u; a.download = 'screenshot.png';
          document.body.appendChild(a); a.click(); a.remove();
        }
      });

      // Side panel proxies
      btnExportOBJ.addEventListener('click', () => btn3D.click());
      btnExportGLTF.addEventListener('click', () => btn3D.click());
      btnScreenshot.addEventListener('click', () => btn3D.click());

    })();
  </script>
</body>

</html>